# -*- coding: utf-8 -*-
"""[AGENTE] Agente Severino

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o00dLd3blgUkNGF5gj5KNMUInnfi-iqj
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip -q install google-genai

# Configura a API Key do Google Gemini

import os
from google.colab import userdata

os.environ["GOOGLE_API_KEY"] = userdata.get('GOOGLE_API_KEY')

# Configura o cliente da SDK do Gemini

from google import genai

client = genai.Client()

MODEL_ID = "gemini-2.0-flash"

# Pergunta ao Gemini uma informação mais recente que seu conhecimento

from IPython.display import HTML, Markdown

# Exibe a busca
#print(f"Busca realizada: {response.candidates[0].grounding_metadata.web_search_queries}")
# Exibe as URLs nas quais ele se baseou
#print(f"Páginas utilizadas na resposta: {', '.join([site.web.title for site in response.candidates[0].grounding_metadata.grounding_chunks])}")
#print()
#display(HTML(response.candidates[0].grounding_metadata.search_entry_point.rendered_content))

# Instalar Framework ADK de agentes do Google ################################################
!pip install -q google-adk

from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools import google_search
from google.genai import types  # Para criar conteúdos (Content e Part)
from datetime import date
import textwrap # Para formatar melhor a saída de texto
from IPython.display import display, Markdown # Para exibir texto formatado no Colab
import requests # Para fazer requisições HTTP
import warnings

warnings.filterwarnings("ignore")

# Função auxiliar que envia uma mensagem para um agente via Runner e retorna a resposta final
def call_agent(agent: Agent, message_text: str) -> str:
    # Cria um serviço de sessão em memória
    session_service = InMemorySessionService()
    # Cria uma nova sessão (você pode personalizar os IDs conforme necessário)
    session = session_service.create_session(app_name=agent.name, user_id="user1", session_id="session1")
    # Cria um Runner para o agente
    runner = Runner(agent=agent, app_name=agent.name, session_service=session_service)
    # Cria o conteúdo da mensagem de entrada
    content = types.Content(role="user", parts=[types.Part(text=message_text)])

    final_response = ""
    # Itera assincronamente pelos eventos retornados durante a execução do agente
    for event in runner.run(user_id="user1", session_id="session1", new_message=content):
        if event.is_final_response():
          for part in event.content.parts:
            if part.text is not None:
              final_response += part.text
              final_response += "\n"
    return final_response

# Função auxiliar para exibir texto formatado em Markdown no Colab
def to_markdown(text):
  text = text.replace('•', '  *')
  return Markdown(textwrap.indent(text, '> ', predicate=lambda _: True))

##########################################
# --- Agente 1: Buscador de Soluções --- #
##########################################
# Inserir as instruções do Agente Buscador de Soluções #################################################
def agente_buscador(problema, data_de_hoje):
  buscador = Agent(
      name="agente_buscador",
      model="gemini-2.0-flash",
      description="Agente que busca soluções para problemas cotidianos",
      tools = [google_search],
      instruction = """
        Você é um assistente de pesquisas domésticas. A sua tarefa é usar a faerramenta de busca do google (google_search)
        para recuperar os resultados mais relevantes para solucionar os problemas pesquisados pelos usuários.
        Foque em, no máximo, 5 fontes diferentes, com na autoridade dos domínios e na quantidade de interações rastreadas para a fonte.
        Se uma fonte não for de um domínio com autoridade alta e não tiver interações rastreadas, ignore-a.
        Ao final, você escolherá a solução mais relevante entre elas com base nas suas pesquisas e irá retorná-la como
        opção mais segura.
      """
  )
  entrada_do_agente_buscador = f"Problema: {problema}\nData de hoje: {data_de_hoje}"
  solucoes = call_agent(buscador, entrada_do_agente_buscador)
  return solucoes

######################################
# --- Agente 2: Severino Resolve --- #
######################################
def agente_severino(problema, solucoes_mais_provaveis):
    severino = Agent(
        name="agente_severino",
        model="gemini-2.0-flash",
        instruction="""
            Você é um Marido de Aluguel especializado em explicar de maneira clara e com vocabulário
            acessível quais são as melhores soluções para os problemas que são buscados pelos usuários.
            Você é o Agente Severino, o melhor Marido de Aluguel Digital que existe no Brasil.
            Utilize as soluções ranqueadas pelo agende planejador e, com base nisso,
            descreva a melhor solução para o usuário. Se o usuário julgar que sua primeira resposta não foi útil,
            forneça uma segunda opção, com base na ordem criada pelo agente planejador.
            Você não deve utilizar gírias. Seu tom de voz é respeitoso, mas leve e amigável.
            Depois de enviar a resposta, você deve perguntar para o usuário se ele gostaria que você buscasse por
            prestadores de serviço que possam ajudar a resolver o problema buscado pelo usuário originalmente.
            Se o usuário disser que sim, ele deverá informar a cidade e o estado onde ele mora.
            """,
        description="Agente Marido de Aluguel que soluciona problemas cotidianos"
    )
    entrada_do_agente_severino = f"Problema: {problema}\nSoluções mais prováveis: {solucoes_mais_provaveis}"
    # Executa o agente
    solucao = call_agent(severino, entrada_do_agente_severino)
    return solucao

#######################################
# --- Agente 3: Severino Pergunta --- #
#######################################
def agente_questionador(problema, cidade, estado):
    questionador = Agent(
        name="agente_questionador",
        model="gemini-2.0-flash",
        tools = [google_search],
        instruction="""
            Você é um Marido de Aluguel que irá pesquisar prestadores de serviço utilizando a tools (google_search) para indicar ao usuário.
            Depois que ele informar a cidade o estado onde reside, você deve utilizar a tools (google_search) para buscar por profissionais
            que podem ajudar a resolver o problema que o usuário pesquisou inicialmente.
            """,
        description="Agente Marido de Aluguel que busca por prestadores de serviço"
    )
    entrada_do_agente_questionador = f"Problema: {problema}\nCidade: {cidade}\nEstado: {estado}"
    # Executa o agente
    pergunta = call_agent(questionador, entrada_do_agente_questionador)
    return pergunta

######################################
# --- Agente 4: Severino Indica --- #
######################################
def agente_indicador(problema, indicacoes):
    indicador = Agent(
        name="agente_indicador",
        model="gemini-2.0-flash",
        tools = [google_search],
        instruction="""
            Você é um Marido de Aluguel que acabou de pesquisar prestadores de serviço que podem solucionar o problema pesquisado pelo usuário.
            Utilizando a tools (google_search), você deverá analisar quais prestadores são mais relevantes com base
            na quantidade de avaliações e da nota. Caso os prestadores de serviço encontrados não possuam avaliações, considerar os
            resultados por ordem de exibição na tools (google_search).
            Você deverá informar ao usuário o nome do prestador de serviço / empresa, o endereço e o telefone. Listas apenas 3 opções.
            """,
        description="Agente Marido de Aluguel que indica prestadores de serviço"
    )
    entrada_do_agente_indicador = f"Problema: {problema}\nIndicações: {indicacoes}"
    # Executa o agente
    indicacao = call_agent(indicador, entrada_do_agente_indicador)
    return indicacao

data_de_hoje = date.today().strftime("%d/%m/%Y")

# --- Obter o Problema do Usuário ---
problema = input("❓ Por favor, digite qual problema ou dificuldade você está enfrentando. ")

# Inserir lógica do sistema de agentes ################################################

if not problema:
  print("Você ainda não me contou com o que precisa de ajuda!")
else:
  print(f"Maravilha! Deixa comigo que já te digo o que fazer!")

problemas_buscados = agente_buscador(problema, data_de_hoje)
#print("\n--- Resultados do Agente 1 ---\n")
#display(to_markdown(problemas_buscados))
#print("----------------------1------------------------")

melhor_solucao = agente_severino(problema, problemas_buscados)
#print("\n--- Resultados do Agente 3 ---\n")
display(to_markdown(melhor_solucao))
#print("---------------------2-------------------------")

# --- Obter Cidade/Estado do Usuário ---
cidade = input("❓ Por favor, informe sua Cidade: ")

if not cidade:
  print("Preciso que me diga o nome da sua cidade para buscar por profissionais que te ajudem!")
else:
  print(f"Muito obrigado")

estado = input("❓ Agora, por favor, informe seu Estado: ")

if not estado:
  print("Preciso que me diga o nome do seu estado para buscar por profissionais que te ajudem!")
else:
  print("Perfeito, deixe-me buscar pelos profissionais.")

avaliacoes = agente_questionador(problema, cidade, estado)
#print("\n--- Resultados do Agente 2 ---\n")
#display(to_markdown(avaliacoes))
#print("----------------------------------------------")

profissionais = agente_indicador(problema, avaliacoes)
print("\n--- Seguem alguns dos profissionais melhor avaliados na sua cidade ---\n")
display(to_markdown(profissionais))
print("----------------------------------------------")

# Interface editável

from IPython.display import display, HTML

# Define estilos CSS para a interface
css_styles = """
<style>
    body {{ font-family: Arial, sans-serif; margin: 20px; background-color: {background_color}; color: {text_color}; }}
    .container {{ max-width: 800px; margin: auto; padding: 20px; border: 1px solid #ccc; border-radius: 10px; background-color: #fff; box-shadow: 2px 2px 12px #aaa; }}
    h1 {{ text-align: center; color: {title_color}; font-size: {title_font_size}; }}
    img {{ display: block; margin: 20px auto; max-width: 100%; height: auto; border-radius: 8px; }}
    .input-section {{ margin-bottom: 20px; }}
    .output-section {{ margin-top: 20px; padding: 15px; background-color: #f9f9f9; border-left: 4px solid #007bff; }}
    label {{ font-weight: bold; }}
    input[type="text"] {{ width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }}
    button {{ background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }}
    button:hover {{ background-color: #0056b3; }}
</style>
"""

# Parâmetros para personalização da interface (pode ajustar diretamente aqui ou adicionar @param)
background_color = '#f0f0f0' #@param {type:"string"}
text_color = '#333333' #@param {type:"string"}
title_color = '#0056b3' #@param {type:"string"}
title_font_size = '32px' #@param {type:"string"}
image_url = 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgaXi1jk5XKKgbiZWDrucB7XEIdeh7yb9OfSpdHDHHlzh4UWzet-9P1ITLgf-G2zmQwQTYWEf3kXNHSutda0n2ChkdrfewmW_ZeAt4tzRO8pT0CP6-N-3maMNcGFD9jaDttPttxs5HpNA7_3lYL8kvIONQU9sEyNkxsXo8W49M08qgqW_xG5HL9Zx7-tKq0/s320/severino.png' #@param {type:"string"}

# Formata os estilos com os parâmetros
formatted_css_styles = css_styles.format(
    background_color=background_color,
    text_color=text_color,
    title_color=title_color,
    title_font_size=title_font_size
)

# HTML structure for the interface
html_interface = f"""
{formatted_css_styles}
<div class="container">
    <div class="input-section">
        <label for="projectTitle"><h1>Agente Severino</h1></label>
    </div>

    <img src="{image_url}" alt="Imagem do Projeto">

    <div class="input-section">
        <label for="problemInput">❓ Por favor, digite qual problema ou dificuldade você está enfrentando:</label>
        <input type="text" id="problemInput" name="problemInput" placeholder="Descreva seu problema aqui">
    </div>

    <div class="input-section">
        <label for="cityInput">❓ Por favor, informe sua Cidade:</label>
        <input type="text" id="cityInput" name="cityInput" placeholder="Sua cidade">
    </div>

    <div class="input-section">
        <label for="stateInput">❓ Agora, por favor, informe seu Estado:</label>
        <input type="text" id="stateInput" name="stateInput" placeholder="Seu estado">
    </div>

    <button onclick="processInput()">Executar Agentes</button>

    <div class="output-section" id="outputArea">
        <h2>Resultados:</h2>
        <!-- Output from agents will be displayed here -->
    </div>
</div>

<script>
    function processInput() {{
        const problem = document.getElementById('problemInput').value;
        const city = document.getElementById('cityInput').value;
        const state = document.getElementById('stateInput').value;
        const outputArea = document.getElementById('outputArea');

        if (!problem) {{
            outputArea.innerHTML = "<h2>Resultados:</h2><p>Você ainda não me contou com o que precisa de ajuda!</p>";
            return;
        }}
        if (!city) {{
            outputArea.innerHTML = "<h2>Resultados:</h2><p>Preciso que me diga o nome da sua cidade para buscar por profissionais que te ajudem!</p>";
             return;
        }}
         if (!state) {{
            outputArea.innerHTML = "<h2>Resultados:</h2><p>Preciso que me diga o nome do seu estado para buscar por profissionais que te ajudem!</p>";
             return;
        }}


        outputArea.innerHTML = "<h2>Resultados:</h2><p>Maravilha! Deixa comigo que já te digo o que fazer!</p>";

        // This part needs to interact with your Python backend.
        // In a real web app, you would send an AJAX request here.
        // In Colab's simple HTML output, we can't directly call Python functions
        // from the HTML. The execution will happen when you run the cell.
        // The following is a placeholder for where you would handle the results.
        // For this Colab environment, the Python code below this HTML
        // will actually execute the agents based on the values of the input variables.
        // The output will appear below the HTML output.

         outputArea.innerHTML += "<p>Processando...</p>";

        // Since we cannot directly call Python from JS in this Colab HTML,
        // the actual agent execution happens below in the Python code block.
        // The results will be printed to the notebook output, not directly into this HTML div after running the cell.
        // To update the HTML output dynamically, you would need a more complex setup
        // involving server-side rendering or a framework like ipywidgets.
    }}
</script>
"""

display(HTML(html_interface))

# --- Python code to run the agents (executed when the cell is run) ---
# This part runs after the HTML is displayed.
# It uses the input variables defined in the Python code block above the HTML.
# You would need to manually enter the values in the text input fields
# before running the cell to influence the Python execution if you were
# using ipywidgets, but with simple HTML display, the Python variables
# at the time of cell execution determine the agent's input.
# For interactive input within the notebook cells, ipywidgets is a better approach.

# Assuming you manually set the problem, city, and state variables in the cell above
# before running this code block, or you get them from interactive elements
# created with ipywidgets. Since the original request uses input(), we'll simulate
# that, but this won't directly update the HTML interface above after the fact.

# The input variables are already defined in the preceding code.
# The logic for running the agents is also present.
# The results will be printed to the notebook output.

# To integrate the agent output into the HTML interface *dynamically*,
# you would need to use ipywidgets or a more complex web framework.
# With simple HTML output via display(HTML(...)), the Python code
# runs independently of the HTML's interactive elements after the HTML is rendered.

# If you want interactive input and output within the notebook,
# consider using ipywidgets instead of simple HTML and JavaScript.

# Example of how to get the values if you were using ipywidgets
# import ipywidgets as widgets
# from IPython.display import display
#
# problem_widget = widgets.Text(description="Problema:")
# city_widget = widgets.Text(description="Cidade:")
# state_widget = widgets.Text(description="Estado:")
# run_button = widgets.Button(description="Executar")
# output_widget = widgets.Output()
#
# def on_button_click(b):
#     with output_widget:
#         output_widget.clear_output()
#         problema_val = problem_widget.value
#         city_val = city_widget.value
#         state_val = state_widget.value
#         if not problema_val:
#             print("Você ainda não me contou com o que precisa de ajuda!")
#             return
#         if not city_val:
#              print("Preciso que me diga o nome da sua cidade para buscar por profissionais que te ajudem!")
#              return
#         if not state_val:
#              print("Preciso que me diga o nome do seu estado para buscar por profissionais que te ajudem!")
#              return
#
#         print("Maravilha! Deixa comigo que já te digo o que fazer!")
#
#         # Call your agent functions here using problem_val, city_val, state_val
#         # Display results using print or display
#
# run_button.on_click(on_button_click)
#
# display(problem_widget, city_widget, state_widget, run_button, output_widget)

# Since the original code uses input(), we will keep that structure for running
# the agents, but the output will be separate from the static HTML display.

# --- Execution of Agents (based on input() calls in the preceding code) ---
# This part will run when you execute the cell. The input() calls will prompt you
# to enter values in the notebook's interactive prompt below the code cell.
# The HTML displayed above is static after rendering.

# The agent execution logic from your preceding code is already present
# and will run when you execute the cell containing this code.
# The variables `problema`, `cidade`, and `estado` are populated
# by the `input()` calls in the preceding code.
# The display(to_markdown(...)) calls will show the agent output below the HTML interface.